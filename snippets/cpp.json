{
  "cpt": {
    "prefix": "cpt",
    "body": [
      "#ifndef TEMPLATE_HPP",
      "#define TEMPLATE_HPP",
      "#include <bits/stdc++.h>",
      "#define rep(i, n) for (int i = 0; i < int(n); i++)",
      "#define rrep(i, n) for (int i = int(n) - 1; i >= 0; i--)",
      "#define reps(i, n) for (int i = 1; i <= int(n); i++)",
      "#define rreps(i, n) for (int i = int(n); i >= 1; i--)",
      "#define repc(i, n) for (int i = 0; i <= int(n); i++)",
      "#define rrepc(i, n) for (int i = int(n); i >= 0; i--)",
      "#define repi(i, a, b) for (int i = int(a); i < int(b); i++)",
      "#define repic(i, a, b) for (int i = int(a); i <= int(b); i++)",
      "#define all(a) (a).begin(), (a).end()",
      "#define bit32(x) (1 << (x))",
      "#define bit64(x) (1ll << (x))",
      "#define sz(v) ((int) v.size())",
      "using namespace std;",
      "using i64 = long long;",
      "using f80 = long double;",
      "using vi32 = vector<int>;",
      "using vi64 = vector<i64>;",
      "using vf80 = vector<f80>;",
      "using vstr = vector<string>;",
      "template <typename T> class pqasc : public priority_queue<T, vector<T>, greater<T>> {};",
      "template <typename T> class pqdesc : public priority_queue<T, vector<T>, less<T>> {};",
      "template <typename T> void amax(T &x, T y) { x = max(x, y); }",
      "template <typename T> void amin(T &x, T y) { x = min(x, y); }",
      "template <typename T> T power(T x, i64 n, T e = 1) { T r = e; while (n > 0) { if (n & 1) r *= x; x *= x; n >>= 1; } return r; }",
      "template <typename T> istream& operator>>(istream &is, vector<T> &v) { for (auto &x : v) is >> x; return is; }",
      "template <typename T> ostream& operator<<(ostream &os, vector<T> &v) { rep(i, v.size()) { if (i) os << ' '; os << v[i]; } return os; }",
      "template <typename T, typename U> vector<U> make_vector(T&& n, U&& val) { return vector<U>(forward<T>(n), forward<U>(val)); }",
      "template <typename T, typename... Args> decltype(auto) make_vector(T&& n, Args&&... args) { return vector<decltype(make_vector(forward<Args>(args)...))>(forward<T>(n), make_vector(forward<Args>(args)...)); }",
      "const int INF = 1001001001;",
      "const i64 LINF = 1001001001001001001ll;",
      "const int dx[] = {1, 0, -1, 0, 1, 1, -1, -1};",
      "const int dy[] = {0, 1, 0, -1, 1, -1, 1, -1};",
      "#endif",
      "",
      "void solve() {",
      "  $0",
      "}",
      "",
      "int main() {",
      "  ios::sync_with_stdio(0);",
      "  cin.tie(0);",
      "  cout << fixed << setprecision(16);",
      "  cerr << fixed << setprecision(16);",
      "  solve();",
      "  return 0;",
      "}"
    ]
  },
  "graph": {
    "prefix": "graph",
    "body": [
      "template <typename Cap, typename Cost>",
      "struct Graph {",
      "  const Cost INF = numeric_limits<Cost>::max();",
      "  struct Edge {",
      "    int to, rev;",
      "    Cap cap;",
      "    Cost cost;",
      "    Edge(int to, Cap cap, Cost cost, int rev)",
      "      : to(to), cap(cap), cost(cost), rev(rev) {}",
      "  };",
      "  vector<vector<Edge>> g;",
      "  int n;",
      "  Graph(int n) : n(n) {",
      "    g.assign(n, vector<Edge>());",
      "  }",
      "  void add_edge(int v, int u, Cap cap = 1, Cost cost = 0) {",
      "    g[v].emplace_back(u, cap, cost, (int) g[u].size());",
      "    g[u].emplace_back(v, 0, -cost, (int) g[v].size() - 1);",
      "  }",
      "  vector<Edge>& operator[](int x) {",
      "    return g[x];",
      "  }",
      "  Cost min_cost_flow(int s, int t, Cap f) {",
      "    Cost ret = 0;",
      "    while (f > 0) {",
      "      vector<Cost> dist(n, INF);",
      "      vector<int> prevv(n), preve(n);",
      "      dist[s] = 0;",
      "      while (true) {",
      "        bool update = false;",
      "        for (int v = 0; v < n; v++) {",
      "          for (int i = 0; i < g[v].size(); i++) {",
      "            auto &e = g[v][i];",
      "            if (e.cap == 0) continue;",
      "            if (dist[v] == INF || dist[e.to] <= dist[v] + e.cost) continue;",
      "            dist[e.to] = dist[v] + e.cost;",
      "            prevv[e.to] = v, preve[e.to] = i;",
      "            update = true;",
      "          }",
      "        }",
      "        if (!update) break;",
      "      }",
      "      if (dist[t] == INF) return INF;",
      "      Cap cap = f;",
      "      for (int v = t; v != s; v = prevv[v]) {",
      "        cap = min(cap, g[prevv[v]][preve[v]].cap);",
      "      }",
      "      f -= cap;",
      "      ret += cap * dist[t];",
      "      for (int v = t; v != s; v = prevv[v]) {",
      "        auto &e = g[prevv[v]][preve[v]];",
      "        e.cap -= cap;",
      "        g[v][e.rev].cap += cap;",
      "      }",
      "    }",
      "    return ret;",
      "  }",
      "};"
    ]
  },
  "low-link": {
    "prefix": "low-link",
    "body": [
      "template <typename Graph>",
      "struct LowLink {",
      "  using A = vector<int>;",
      "  using B = vector<pair<int, int>>;",
      "  Graph &g;",
      "  int n;",
      "  vector<bool> seen;",
      "  vector<int> ord, low;",
      "  A articulation;",
      "  B bridge;",
      "  LowLink(Graph &g) : g(g), n(g.n) {}",
      "  void dfs(int v, int p, int &k) {",
      "    seen[v] = true;",
      "    ord[v] = k++;",
      "    low[v] = ord[v];",
      "    bool is = false;",
      "    int cnt = 0;",
      "    for (auto e : g[v]) {",
      "      int u = e.to;",
      "      if (seen[u])  {",
      "        if (u != p) low[v] = min(low[v], ord[u]);",
      "        continue;",
      "      }",
      "      cnt++;",
      "      dfs(u, v, k);",
      "      low[v] = min(low[v], low[u]);",
      "      if (p != -1 && ord[v] <= low[u]) is = true;",
      "      if (ord[v] < low[u]) bridge.emplace_back(minmax(v, u));",
      "    }",
      "    if (p == -1 && cnt > 1) is = true;",
      "    if (is) articulation.push_back(v);",
      "  }",
      "  pair<A, B> build() {",
      "    seen.assign(n, false);",
      "    ord.assign(n, 0);",
      "    low.assign(n, 0);",
      "    articulation.clear();",
      "    bridge.clear();",
      "    int k = 0;",
      "    dfs(0, -1, k);",
      "    return pair<A, B>(articulation, bridge);",
      "  }",
      "};"
    ]
  },
  "max-flow": {
    "prefix": "max-flow",
    "body": [
      "template <typename C, typename D>",
      "C max_flow(Graph<C, D> &g, int s, int t) {",
      "  const int n = g.n;",
      "",
      "  C flow = 0;",
      "  vector<int> used(n);",
      "  int ui = 0;",
      "  function<C(int, int, C)> dfs = [&](int v, int t, C f) {",
      "    if (v == t) return f;",
      "    used[v] = ui;",
      "    for (int i = 0; i < g[v].size(); i++) {",
      "      auto &e = g[v][i];",
      "      if (used[e.to] == ui || e.cap == 0) continue;",
      "      int d = dfs(e.to, t, min(f, e.cap));",
      "      if (d == 0) continue;",
      "      e.cap -= d;",
      "      g[e.to][e.rev].cap += d;",
      "      return d;",
      "    }",
      "    return 0;",
      "  };",
      "  while (true) {",
      "    ui++;",
      "    int f = dfs(s, t, numeric_limits<C>::max());",
      "    if (f == 0) return flow;",
      "    flow += f;",
      "  }",
      "}"
    ]
  },
  "strongly-connected-components": {
    "prefix": "strongly-connected-components",
    "body": [
      "template <typename Graph>",
      "struct StronglyConnectedComponents {",
      "  Graph &g;",
      "  int n;",
      "  vector<vector<int>> gg;",
      "  vector<vector<int>> rg;",
      "  vector<bool> used;",
      "  vector<int> order;",
      "  vector<int> group;",
      "  StronglyConnectedComponents(Graph &g)",
      "    : g(g), n(g.n), gg(n), rg(n), used(n), order(n), group(n, -1) {",
      "    for (int v = 0; v < n; v++) {",
      "      for (auto e : g[v]) {",
      "        gg[v].emplace_back(e.to);",
      "        rg[e.to].emplace_back(v);",
      "      }",
      "    }",
      "  }",
      "  void dfs1(int v) {",
      "    if (used[v]) return;",
      "    used[v] = true;",
      "    for (int u : gg[v]) dfs1(u);",
      "    order.push_back(v);",
      "  }",
      "  void dfs2(int v, int c) {",
      "    if (group[v] != -1) return;",
      "    group[v] = c;",
      "    for (int u : rg[v]) dfs2(u, c);",
      "  }",
      "  vector<int> build() {",
      "    for (int i = 0; i < n; i++) {",
      "      dfs1(i);",
      "    }",
      "    reverse(order.begin(), order.end());",
      "    int ptr = 0;",
      "    for (int v : order) {",
      "      if (group[v] == -1) dfs2(v, ptr), ptr++;",
      "    }",
      "    return group;",
      "  }",
      "};"
    ]
  },
  "two-edge-connected-components": {
    "prefix": "two-edge-connected-components",
    "body": [
      "template <typename Graph>",
      "struct TwoEdgeConnectedComponents {",
      "  using B = vector<pair<int, int>>;",
      "  Graph &g;",
      "  int n;",
      "  vector<bool> seen;",
      "  vector<int> group;",
      "  set<pair<int, int>> b;",
      "  TwoEdgeConnectedComponents(Graph &g) : g(g), n(g.n), group(n) {}",
      "  void dfs(int v, int p, int k) {",
      "    seen[v] = true;",
      "    group[v] = k;",
      "    for (auto e : g[v]) {",
      "      int u = e.to;",
      "      if (u == p) continue;",
      "      if (seen[u]) continue;",
      "      if (b.find(minmax(v, u)) != b.end()) continue;",
      "      dfs(u, v, k);",
      "    }",
      "  }",
      "  vector<int> decompose(B bridge) {",
      "    seen.assign(n, false);",
      "    b.clear();",
      "    b.insert(bridge.begin(), bridge.end());",
      "    int k = 0;",
      "    for (int i = 0; i < n; i++) {",
      "      if (seen[i]) continue;",
      "      dfs(i, -1, k++);",
      "    }",
      "    return group;",
      "  }",
      "};"
    ]
  },
  "gcdlcm": {
    "prefix": "gcdlcm",
    "body": [
      "template <typename T>",
      "T gcd(T a, T b) {",
      "  if (min(a, b) == 0) {",
      "    return max(a, b);",
      "  }",
      "  if (a % b == 0) {",
      "    return b;",
      "  } else {",
      "    return gcd(b, a % b);",
      "  }",
      "}",
      "",
      "template <typename T>",
      "T lcm(T a, T b) {",
      "  if (min(a, b) == 0) {",
      "    return max(a, b);",
      "  }",
      "  return a / gcd(a, b) * b;",
      "}"
    ]
  },
  "matrix": {
    "prefix": "matrix",
    "body": [
      "template <typename T>",
      "struct Matrix {",
      "  vector<vector<T>> v;",
      "  int r, c;",
      "  Matrix(int r, int c) : r(r), c(c) {",
      "    v.assign(r, vector<T>(c));",
      "  }",
      "  Matrix(vector<vector<T>> v) : v(v) {",
      "    assert(v.size() > 0 && v[0].size() > 0);",
      "    r = v.size();",
      "    c = v[0].size();",
      "  }",
      "  vector<T>& operator[](int x) {",
      "    return v[x];",
      "  }",
      "  Matrix<T> operator*=(Matrix<T> that) {",
      "    assert(c == that.r);",
      "    auto ret = Matrix<T>(r, that.c);",
      "    for (int i = 0; i < r; i++) {",
      "      for (int j = 0; j < that.c; j++) {",
      "        for (int k = 0; k < c; k++) {",
      "          ret[i][j] += v[i][k] * that[k][j];",
      "        }",
      "      }",
      "    }",
      "    return *this = ret;",
      "  }",
      "  Matrix<T> operator*(Matrix<T> that) {",
      "    return Matrix(*this) *= that;",
      "  }",
      "  Matrix<T> pow(long long n) {",
      "    assert(r == c);",
      "    auto ret = Matrix<T>(r, c);",
      "    for (int i = 0; i < r; i++) {",
      "      ret[i][i] = 1;",
      "    }",
      "    auto temp = *this;",
      "    while (n) {",
      "      if (n & 1) ret *= temp;",
      "      n >>= 1;",
      "      temp *= temp;",
      "    }",
      "    return ret;",
      "  }",
      "  Matrix<T> transpose() {",
      "    Matrix<T> ret(c, r);",
      "    for (int i = 0; i < r; i++) {",
      "      for (int j = 0; j < c; j++) {",
      "        ret[j][i] = v[i][j];",
      "      }",
      "    }",
      "    return ret;",
      "  }",
      "  Matrix<T> inverse() {",
      "    assert(r == c);",
      "    int n = r;",
      "    Matrix<T> m(n, n * 2);",
      "    for (int i = 0; i < n; i++) {",
      "      for (int j = 0; j < n; j++) {",
      "        m[i][j] = v[i][j];",
      "      }",
      "    }",
      "    for (int i = 0; i < n; i++) {",
      "      m[i][i + n] = 1;",
      "    }",
      "    for (int i = 0; i < n; i++) {",
      "      for (int j = i; j < n; j++) {",
      "        if (m[j][i] != (T) 0) {",
      "          swap(m[i], m[j]);",
      "          break;",
      "        }",
      "      }",
      "      T div = m[i][i];",
      "      assert(div != (T) 0);",
      "      for (int j = 0; j < n * 2; j++) {",
      "        m[i][j] /= div;",
      "      }",
      "      for (int j = 0; j < n; j++) {",
      "        if (i == j) continue;",
      "        T mul = m[j][i];",
      "        for (int k = 0; k < n * 2; k++) {",
      "          m[j][k] -= m[i][k] * mul;",
      "        }",
      "      }",
      "    }",
      "    Matrix<T> ret(n, n);",
      "    for (int i = 0; i < n; i++) {",
      "      for (int j = 0; j < n; j++) {",
      "        ret[i][j] = m[i][j + n];",
      "      }",
      "    }",
      "    return ret;",
      "  }",
      "  bool operator==(Matrix<T> that) {",
      "    if (r != that.r) return false;",
      "    if (c != that.c) return false;",
      "    for (int i = 0; i < r; i++) {",
      "      for (int j = 0; j < c; j++) {",
      "        if (v[i][j] != that[i][j]) {",
      "          return false;",
      "        }",
      "      }",
      "    }",
      "    return true;",
      "  }",
      "};"
    ]
  },
  "modcalc": {
    "prefix": "modcalc",
    "body": [
      "template <typename T>",
      "struct ModCalc {",
      "  vector<T> facc;",
      "  vector<T> finv;",
      "  ModCalc(int max) {",
      "    facc.resize(max + 1);",
      "    finv.resize(max + 1);",
      "    facc[0] = 1;",
      "    for (int i = 0; i < max; i++) {",
      "      facc[i + 1] = facc[i] * (i + 1);",
      "    }",
      "    finv[max] = (T) 1 / facc[max];",
      "    for (int i = max; i > 0; i--) {",
      "      finv[i - 1] = finv[i] * i;",
      "    }",
      "  }",
      "  T com(int a, int b) {",
      "    if (a < 0 || b < 0 || b > a) return 0;",
      "    return facc[a] * finv[a - b] * finv[b];",
      "  }",
      "};",
      "",
      "using mcalc = ModCalc<mint>;"
    ]
  },
  "modint": {
    "prefix": "modint",
    "body": [
      "template <int mod>",
      "struct ModInt {",
      "  int x;",
      "  ModInt(): x(0) {}",
      "  ModInt(long long a) { x = a % mod; if (x < 0) x += mod; }",
      "  ModInt &operator+=(ModInt that) { x = (x + that.x) % mod; return *this; }",
      "  ModInt &operator-=(ModInt that) { x = (x + mod - that.x) % mod; return *this; }",
      "  ModInt &operator*=(ModInt that) { x = (long long) x * that.x % mod; return *this; }",
      "  ModInt &operator/=(ModInt that) { return *this *= that.inverse(); }",
      "  ModInt inverse() {",
      "    int a = x, b = mod, u = 1, v = 0;",
      "    while (b) { int t = a / b; a -= t * b; u -= t * v; swap(a, b); swap(u, v); }",
      "    return ModInt(u);",
      "  }",
      "  #define op(o, p) ModInt operator o(ModInt that) { return ModInt(*this) p that; }",
      "    op(+, +=) op(-, -=) op(*, *=) op(/, /=)",
      "  #undef op",
      "  friend ostream& operator<<(ostream &os, ModInt m) { return os << m.x; }",
      "  bool operator==(const ModInt& that) { return x == that.x; }",
      "  bool operator!=(const ModInt& that) { return x != that.x; }",
      "};",
      "",
      "using mint = ModInt<1000000007>;"
    ]
  },
  "prime": {
    "prefix": "prime",
    "body": [
      "struct Prime {",
      "  int n;",
      "  vector<int> pri;",
      "  Prime(int n) : n(n) {",
      "    vector<bool> f(n, true);",
      "    f[0] = f[1] = false;",
      "    for (int i = 2; i < n; i++) {",
      "      if (!f[i]) continue;",
      "      pri.push_back(i);",
      "      for (int j = i * 2; j < n; j += i) {",
      "        f[j] = false;",
      "      }",
      "    }",
      "  }",
      "  map<int, int> factor(int k) {",
      "    map<int, int> so;",
      "    for (auto p : pri) {",
      "      while (k % p == 0) k /= p, so[p]++;",
      "    }",
      "    if (k != 1) so[k] = 1;",
      "    return so;",
      "  }",
      "};"
    ]
  },
  "vec2": {
    "prefix": "vec2",
    "body": [
      "struct Vec2 {",
      "  double x, y;",
      "  Vec2() : x(0), y(0) {}",
      "  Vec2(double x, double y) : x(x), y(y) {}",
      "  Vec2& operator+=(Vec2 that) { x += that.x, y += that.y; return *this; }",
      "  Vec2& operator-=(Vec2 that) { x -= that.x, y -= that.y; return *this; }",
      "  Vec2& operator*=(double s) { x *= s, y *= s; return *this; }",
      "  Vec2& operator/=(double s) { x /= s, y /= s; return *this; }",
      "  Vec2 operator+(Vec2 that) const { return Vec2(*this) += that; }",
      "  Vec2 operator-(Vec2 that) const { return Vec2(*this) -= that; }",
      "  Vec2 operator*(double that) const { return Vec2(*this) *= that; }",
      "  Vec2 operator/(double that) const { return Vec2(*this) /= that; }",
      "  double dot(Vec2 that) const { return x * that.x + y * that.y; }",
      "  double cross(Vec2 that) const { return x * that.y - y * that.x; }",
      "  double length() const { return hypot(x, y); }",
      "  Vec2 normal() const { return Vec2(*this) / (*this).length(); }",
      "  friend istream& operator>>(istream &is, Vec2 &v) { return is >> v.x >> v.y; }",
      "  friend ostream& operator<<(ostream &os, Vec2 &v) { return os << \"(\" << v.x << \", \" << v.y << \")\"; }",
      "};"
    ]
  },
  "compress": {
    "prefix": "compress",
    "body": [
      "template <typename T>",
      "struct Compress {",
      "  vector<T> v;",
      "  Compress() {}",
      "  Compress(vector<T> _v) : v(_v) {",
      "    build();",
      "  }",
      "  void insert(T x) {",
      "    v.push_back(x);",
      "  }",
      "  void insert(vector<T> x) {",
      "    for (int i = 0; i < (int) x.size(); i++) {",
      "      v.push_back(x[i]);",
      "    }",
      "  }",
      "  void build() {",
      "    sort(v.begin(), v.end());",
      "    v.erase(unique(v.begin(), v.end()), v.end());",
      "  }",
      "  int get(T x) {",
      "    return lower_bound(v.begin(), v.end(), x) - v.begin();",
      "  }",
      "  int size() {",
      "    return (int) v.size();",
      "  }",
      "  T& operator[](int k) {",
      "    return v[k];",
      "  }",
      "};"
    ]
  },
  "xor-shift": {
    "prefix": "xor-shift",
    "body": [
      "inline unsigned long long xorshift() {",
      "  static unsigned long long x = 88172645463325252ull;",
      "  x = x ^ (x << 7);",
      "  return x = x ^ (x >> 9);",
      "}"
    ]
  },
  "kmp": {
    "prefix": "kmp",
    "body": [
      "vector<int> kmp(const string &s, const string &t) {",
      "  vector<int> ta(t.size() + 1);",
      "  {",
      "    ta[0] = -1;",
      "    int j = -1;",
      "    for (int i = 0; i < t.size(); i++) {",
      "      while (j >= 0 && t[i] != t[j]) j = ta[j];",
      "      ta[i + 1] = ++j;",
      "    }",
      "  }",
      "  vector<int> ret;",
      "  int m = 0, i = 0, n = s.size();",
      "  while (m + i < n) {",
      "    if (t[i] == s[m + i]) {",
      "      if (++i == (int) t.size()) {",
      "        ret.push_back(m);",
      "        m = m + i - ta[i];",
      "        i = ta[i];",
      "      }",
      "    } else {",
      "      m = m + i - ta[i];",
      "      if (i > 0) i = ta[i];",
      "    }",
      "  }",
      "  return ret;",
      "}"
    ]
  },
  "rolling-hash": {
    "prefix": "rolling-hash",
    "body": [
      "struct RollingHash {",
      "  const int h = 1000000007;",
      "  const int b = 10007;",
      "  vector<int> ha;",
      "  vector<int> po;",
      "  RollingHash(const string &s) {",
      "    int n = (int) s.size();",
      "    ha.assign(n + 1, 0);",
      "    po.assign(n + 1, 1);",
      "    for (int i = 0; i < n; i++) {",
      "      ha[i + 1] = ((long long) ha[i] * b + s[i]) % h;",
      "      po[i + 1] = ((long long) po[i] * b) % h;",
      "    }",
      "  }",
      "  int get(int l, int r) {",
      "    return (ha[r] + h - ((long long) ha[l] * po[r - l]) % h) % h;",
      "  }",
      "};"
    ]
  },
  "suffix-array": {
    "prefix": "suffix-array",
    "body": [
      "struct SuffixArray {",
      "  vector<int> sa;",
      "  SuffixArray(const string &s) {",
      "    sa = sa_is(s);",
      "  }",
      "  int operator[](int k) {",
      "    return sa[k];",
      "  }",
      "  vector<int> sa_is(const string &s) {",
      "    vector<char> c(s.begin(), s.end());",
      "    c.push_back('\\0');",
      "    return sa_is(c, 128);",
      "  }",
      "  template <typename T>",
      "  vector<int> sa_is(vector<T> &s, int k) {",
      "    int n = s.size();",
      "    vector<bool> t(n);",
      "    t[n - 1] = 1;",
      "    for (int i = n - 2; i >= 0; i--) {",
      "      t[i] = s[i] < s[i + 1] || s[i] == s[i + 1] && t[i + 1];",
      "    }",
      "    vector<int> lmss;",
      "    for (int i = 0; i < n; i++) {",
      "      if (is_lms(t, i)) lmss.push_back(i);",
      "    }",
      "    vector<int> sa = induced_sort(s, k, t, lmss);",
      "    int n1 = 0;",
      "    for (int i = 0; i < n; i++) {",
      "      if (is_lms(t, sa[i])) sa[n1++] = sa[i];",
      "    }",
      "    for (int i = n1; i < n; i++) {",
      "      sa[i] = -1;",
      "    }",
      "    int name = 0, prev = -1;",
      "    for (int i = 0; i < n1; i++) {",
      "      int pos = sa[i];",
      "      bool diff = false;",
      "      for (int d = 0; d < n; d++) {",
      "        if (prev == -1 || s[pos + d] != s[prev + d] || t[pos + d] != t[prev + d]) {",
      "          diff = true;",
      "          break;",
      "        } else if (d > 0 && (is_lms(t, pos + d) || is_lms(t, prev + d))) {",
      "          break;",
      "        }",
      "      }",
      "      if (diff) name++, prev = pos;",
      "      pos = (pos % 2 == 0) ? pos / 2 : (pos - 1) / 2;",
      "      sa[n1 + pos] = name - 1;",
      "    }",
      "    vector<int> nums;",
      "    for (int i = n1; i < n; i++) {",
      "      if (sa[i] >= 0) nums.push_back(sa[i]);",
      "    }",
      "    if (name < n1) {",
      "      sa = sa_is(nums, name + 1);",
      "    } else {",
      "      for (int i = 0; i < n1; i++) {",
      "        sa[nums[i]] = i;",
      "      }",
      "    }",
      "    vector<int> seed;",
      "    for (int i = 0; i < n1; i++) {",
      "      seed.push_back(lmss[sa[i]]);",
      "    }",
      "    return induced_sort(s, k, t, seed);",
      "  }",
      "  template <typename T>",
      "  vector<int> induced_sort(vector<T> &s, int k, vector<bool> &t, vector<int> &lmss) {",
      "    int n = s.size();",
      "    vector<int> sa(n, -1);",
      "    vector<int> bin(k + 1);",
      "    for (int i = 0; i < n; i++) bin[s[i] + 1]++;",
      "    for (int i = 0; i < k; i++) bin[i + 1] += bin[i];",
      "    vector<int> cnt(k);",
      "    for (int i = lmss.size() - 1; i >= 0; i--) {",
      "      auto c = s[lmss[i]];",
      "      sa[bin[c + 1] - cnt[c] - 1] = lmss[i];",
      "      cnt[c]++;",
      "    }",
      "    cnt.assign(k, 0);",
      "    for (int i = 0; i < n; i++) {",
      "      if (sa[i] <= 0 || t[sa[i] - 1]) continue;",
      "      auto c = s[sa[i] - 1];",
      "      sa[bin[c] + cnt[c]] = sa[i] - 1;",
      "      cnt[c]++;",
      "    }",
      "    cnt.assign(k, 0);",
      "    for (int i = n - 1; i >= 0; i--) {",
      "      if (sa[i] <= 0 || !t[sa[i] - 1]) continue;",
      "      auto c = s[sa[i] - 1];",
      "      sa[bin[c + 1] - cnt[c] - 1] = sa[i] - 1;",
      "      cnt[c]++;",
      "    }",
      "    return sa;",
      "  }",
      "  inline bool is_lms(vector<bool> &t, int i) {",
      "    return i > 0 && t[i] && !t[i - 1];",
      "  }",
      "};"
    ]
  },
  "z-algorithm": {
    "prefix": "z-algorithm",
    "body": [
      "vector<int> z_algorithm(const string &s) {",
      "  int n = s.size();",
      "  vector<int> a(n);",
      "  a[0] = n;",
      "  int i = 1, j = 0;",
      "  while (i < n) {",
      "    while (i + j < n && s[j] == s[i + j]) j++;",
      "    a[i] = j;",
      "    if (j == 0) { i++; continue; }",
      "    int k = 1;",
      "    while (i + k < n && k + a[k] < j) a[i + k] = a[k], k++;",
      "    i += k, j -= k;",
      "  }",
      "  return a;",
      "}"
    ]
  },
  "fenwick-tree": {
    "prefix": "fenwick-tree",
    "body": [
      "template <typename T>",
      "struct FenwickTree {",
      "  vector<T> v;",
      "  int n;",
      "  FenwickTree(int n) : n(n) {",
      "    v = vector<T>(n);",
      "  }",
      "  void update(int i, T x) {",
      "    for (i++; i <= n; i += i & -i) v[i - 1] += x;",
      "  }",
      "  T query(int i) {",
      "    T r = 0;",
      "    for (; i >= 1; i -= i & -i) r += v[i - 1];",
      "    return r;",
      "  }",
      "};"
    ]
  },
  "lazy-segment-tree": {
    "prefix": "lazy-segment-tree",
    "body": [
      "template <typename T, typename S>",
      "struct LazySegmentTree {",
      "  vector<T> v;",
      "  vector<S> z;",
      "  function<T(T, T)> f;",
      "  function<T(T, S, int)> g;",
      "  function<S(S, S)> h;",
      "  T e;",
      "  S d;",
      "  int n;",
      "  LazySegmentTree(",
      "    int size,",
      "    function<T(T, T)> f,",
      "    function<T(T, S, int)> g,",
      "    function<S(S, S)> h,",
      "    T e, ",
      "    S d",
      "  ) : f(f), g(g), h(h), e(e), d(d) {",
      "    n = 1;",
      "    while (n < size) n <<= 1;",
      "    v.resize(n * 2, e);",
      "    z.resize(n * 2, d);",
      "  }",
      "  void set(int k, T x) {",
      "    v[k + n] = x;",
      "  }",
      "  void build() {",
      "    for (int i = n - 1; i >= 0; i--) {",
      "      v[i] = f(v[i * 2 + 0], v[i * 2 + 1]);",
      "    }",
      "  }",
      "  void propagate(int k, int l, int r) {",
      "    v[k] = g(v[k], z[k], r - l);",
      "    if (k < n) {",
      "      z[k * 2 + 0] = h(z[k * 2 + 0], z[k]);",
      "      z[k * 2 + 1] = h(z[k * 2 + 1], z[k]);",
      "    }",
      "    z[k] = d;",
      "  }",
      "  T update(int a, int b, S x, int k = 1, int l = 0, int r = -1) {",
      "    if (r == -1) r = n;",
      "    propagate(k, l, r);",
      "    if (b <= l || r <= a) return v[k];",
      "    if (a <= l && r <= b) { z[k] = x; propagate(k, l, r); return v[k]; }",
      "    return v[k] = f(",
      "      update(a, b, x, k * 2 + 0, l, (l + r) / 2),",
      "      update(a, b, x, k * 2 + 1, (l + r) / 2, r)",
      "    );",
      "  }",
      "  T query(int a, int b, int k = 1, int l = 0, int r = -1) {",
      "    if (r == -1) r = n;",
      "    propagate(k, l, r);",
      "    if (b <= l || r <= a) return e;",
      "    if (a <= l && r <= b) return v[k];",
      "    return f(",
      "      query(a, b, k * 2 + 0, l, (l + r) / 2),",
      "      query(a, b, k * 2 + 1, (l + r) / 2, r)",
      "    );",
      "  }",
      "};"
    ]
  },
  "segment-tree": {
    "prefix": "segment-tree",
    "body": [
      "template <typename T>",
      "struct SegmentTree {",
      "  vector<T> v;",
      "  function<T(T, T)> f;",
      "  T e;",
      "  int n;",
      "  SegmentTree(int size, function<T(T, T)> f, T e) : f(f), e(e) {",
      "    n = 1;",
      "    while (n < size) n <<= 1;",
      "    v.resize(n * 2, e);",
      "  }",
      "  void set(int k, T x) {",
      "    v[k + n] = x;",
      "  }",
      "  void build() {",
      "    for (int i = n - 1; i > 0; i--) {",
      "      v[i] = f(v[i * 2 + 0], v[i * 2 + 1]);",
      "    }",
      "  }",
      "  void update(int k, T x) {",
      "    v[k += n] = x;",
      "    while (k >>= 1) v[k] = f(v[k * 2 + 0], v[k * 2 + 1]);",
      "  }",
      "  T query(int a, int b) {",
      "    T l = e, r = e;",
      "    for (a += n, b += n; a < b; a >>= 1, b >>= 1) {",
      "      if (a & 1) l = f(l, v[a++]);",
      "      if (b & 1) r = f(v[--b], r);",
      "    }",
      "    return f(l, r);",
      "  }",
      "  void reset(int k) {",
      "    update(k, e);",
      "  }",
      "  T operator[](int k) {",
      "    return query(k, k + 1);",
      "  }",
      "};"
    ]
  },
  "union-find": {
    "prefix": "union-find",
    "body": [
      "struct UnionFind {",
      "  vector<int> data;",
      "  UnionFind(int n) {",
      "    data.assign(n, -1);",
      "  }",
      "  int root(int k) {",
      "    if (data[k] < 0) return k;",
      "    return data[k] = root(data[k]);",
      "  }",
      "  void unite(int x, int y) {",
      "    x = root(x);",
      "    y = root(y);",
      "    if (x == y) return;",
      "    if (data[x] > data[y]) swap(x, y);",
      "    data[x] += data[y];",
      "    data[y] = x;",
      "  }",
      "  bool same(int x, int y) {",
      "    return root(x) == root(y);",
      "  }",
      "  int size(int k) {",
      "    return -data[root(k)];",
      "  }",
      "};"
    ]
  },
  "heavy-light-decomposition": {
    "prefix": "heavy-light-decomposition",
    "body": [
      "struct HeavyLightDecomposition {",
      "  vector<vector<int>> g;",
      "  vector<int> vid;",
      "  vector<int> out;",
      "  vector<int> head;",
      "  vector<int> par;",
      "  vector<int> ddep;",
      "  HeavyLightDecomposition(vector<vector<int>> g) : g(g) {",
      "    int n = g.size();",
      "    vid = vector<int>(n);",
      "    out = vector<int>(n);",
      "    head = vector<int>(n);",
      "    par = vector<int>(n, -1);",
      "    ddep = vector<int>(n);",
      "    {",
      "      vector<int> size(n);",
      "      auto dfs = [&](auto dfs, int u, int p) -> void {",
      "        size[u] = 1;",
      "        for (auto &v : g[u]) if (v != p) {",
      "          par[v] = u;",
      "          dfs(dfs, v, u);",
      "          size[u] += size[v];",
      "          if (size[v] > size[g[u][0]]) swap(v, g[u][0]);",
      "        }",
      "      };",
      "      dfs(dfs, 0, -1);",
      "    }",
      "    {",
      "      int t = 0;",
      "      auto dfs = [&](auto dfs, int u, int p) -> void {",
      "        vid[u] = t++;",
      "        for (auto v : g[u]) if (v != p) {",
      "          if (v == g[u][0]) {",
      "            head[v] = head[u];",
      "            ddep[v] = ddep[u];",
      "          } else {",
      "            head[v] = v;",
      "            ddep[v] = ddep[u] + 1;",
      "          }",
      "          dfs(dfs, v, u);",
      "        }",
      "        out[u] = t;",
      "      };",
      "      dfs(dfs, 0, -1);",
      "    }",
      "  }",
      "  void for_each(int u, int v, function<void(int, int)> f) {",
      "    while (true) {",
      "      if (ddep[u] > ddep[v]) swap(u, v);",
      "      if (head[u] == head[v]) {",
      "        f(min(vid[u], vid[v]), max(vid[u], vid[v]) + 1);",
      "        return;",
      "      }",
      "      f(vid[head[v]], vid[v] + 1);",
      "      v = par[head[v]];",
      "    }",
      "  }",
      "  void for_each_edge(int u, int v, function<void(int, int)> f) {",
      "    while (true) {",
      "      if (ddep[u] > ddep[v]) swap(u, v);",
      "      if (head[u] == head[v]) {",
      "        f(min(vid[u], vid[v]) + 1, max(vid[u], vid[v]) + 1);",
      "        return;",
      "      }",
      "      f(vid[head[v]], vid[v] + 1);",
      "      v = par[head[v]];",
      "    }",
      "  }",
      "  int lca(int u, int v) {",
      "    while (true) {",
      "      if (ddep[u] > ddep[v]) swap(u, v);",
      "      if (head[u] == head[v]) {",
      "        return vid[u] < vid[v] ? u : v;",
      "      }",
      "      v = par[head[v]];",
      "    }",
      "  }",
      "  pair<int, int> subtree(int u) {",
      "    return make_pair(vid[u], out[u]);",
      "  }",
      "  pair<int, int> subtree_edge(int u) {",
      "    return make_pair(vid[u] + 1, out[u]);",
      "  }",
      "  int operator[](int k) {",
      "    return vid[k];",
      "  }",
      "};"
    ]
  },
  "link-cut-tree": {
    "prefix": "link-cut-tree",
    "body": [
      "struct LinkCutTree {",
      "  struct Node {",
      "    Node *l, *r, *p;",
      "    int k;",
      "    Node(int k) : k(k), l(nullptr), r(nullptr), p(nullptr) {}",
      "    bool is_root() {",
      "      return !p || (p->l != this && p->r != this);",
      "    }",
      "  };",
      "  int n;",
      "  vector<Node *> nodes;",
      "  LinkCutTree(int n) : n(n), nodes(n) {",
      "    for (int i = 0; i < n; i++) {",
      "      nodes[i] = new Node(i);",
      "    }",
      "  }",
      "  void rotr(Node *t) {",
      "    auto *x = t->p, *y = x->p;",
      "    if ((x->l = t->r)) t->r->p = x;",
      "    t->r = x, x->p = t;",
      "    if ((t->p = y)) {",
      "      if (y->l == x) y->l = t;",
      "      if (y->r == x) y->r = t;",
      "    }",
      "  }",
      "  void rotl(Node *t) {",
      "    auto *x = t->p, *y = x->p;",
      "    if ((x->r = t->l)) t->l->p = x;",
      "    t->l = x, x->p = t;",
      "    if ((t->p = y)) {",
      "      if (y->l == x) y->l = t;",
      "      if (y->r == x) y->r = t;",
      "    }",
      "  }",
      "  void splay(Node *t) {",
      "    while (!t->is_root()) {",
      "      auto *p = t->p;",
      "      if (p->is_root()) {",
      "        if (p->l == t) rotr(t);",
      "        else rotl(t);",
      "        continue;",
      "      }",
      "      auto *q = p->p;",
      "      if (q->l == p) {",
      "        if (p->l == t) rotr(p), rotr(t);",
      "        else rotl(t), rotr(t);",
      "      } else {",
      "        if (p->r == t) rotl(p), rotl(t);",
      "        else rotr(t), rotl(t);",
      "      }",
      "    }",
      "  }",
      "  int expose(int k) {",
      "    Node *t = nodes[k];",
      "    Node *rp = nullptr;",
      "    for (auto *cur = t; cur; cur = cur->p) {",
      "      splay(cur);",
      "      cur->r = rp;",
      "      rp = cur;",
      "    }",
      "    splay(t);",
      "    return rp->k;",
      "  }",
      "  void link(int v, int u) {",
      "    expose(v);",
      "    expose(u);",
      "    nodes[v]->p = nodes[u];",
      "    nodes[u]->r = nodes[v];",
      "  }",
      "  int lca(int v, int u) {",
      "    expose(v);",
      "    return expose(u);",
      "  }",
      "};"
    ]
  },
  "lowest-common-ancestor": {
    "prefix": "lowest-common-ancestor",
    "body": [
      "struct LowestCommonAncestor {",
      "  vector<vector<int>> g;",
      "  int n;",
      "  int l = 0;",
      "  vector<vector<int>> par;",
      "  vector<int> dep;",
      "  LowestCommonAncestor(int n) : n(n), g(n), dep(n) {",
      "    while ((1 << l) < n) l++;",
      "    par.assign(n + 1, vector<int>(l, n));",
      "  }",
      "  void add_edge(int u, int v) {",
      "    g[u].push_back(v);",
      "    g[v].push_back(u);",
      "  }",
      "  void build(int root = 0) {",
      "    auto dfs = [&](auto dfs, int u, int p, int d) -> void {",
      "      if (p != -1) par[u][0] = p;",
      "      dep[u] = d;",
      "      for (auto v : g[u]) if (v != p) {",
      "        dfs(dfs, v, u, d + 1);",
      "      }",
      "    };",
      "    dfs(dfs, root, -1, 0);",
      "    for (int i = 0; i < l - 1; i++) {",
      "      for (int u = 0; u < n; u++) {",
      "        par[u][i + 1] = par[par[u][i]][i];",
      "      }",
      "    }",
      "  }",
      "  int operator()(int u, int v) {",
      "    if (dep[u] < dep[v]) swap(u, v);",
      "    int gap = dep[u] - dep[v];",
      "    for (int i = l - 1; i >= 0; i--) {",
      "      if ((1 << i) & gap) u = par[u][i];",
      "    }",
      "    if (u == v) return u;",
      "    for (int i = l - 1; i >= 0; i--) {",
      "      int pv = par[u][i];",
      "      int pu = par[v][i];",
      "      if (pv != pu) u = pv, v = pu;",
      "    }",
      "    return par[u][0];",
      "  }",
      "  int dist(int u, int v) {",
      "    int a = (*this)(u, v);",
      "    return dep[u] + dep[v] - dep[a] * 2;",
      "  }",
      "};"
    ]
  },
  "rerooting": {
    "prefix": "rerooting",
    "body": [
      "template <typename T, typename Data>",
      "struct ReRooting {",
      "  using M = function<T(T, T)>;",
      "  using L = function<T(T, Data)>;",
      "  struct Edge {",
      "    int to;",
      "    Data data;",
      "  };",
      "  int n;",
      "  L lift;",
      "  M merge;",
      "  vector<vector<Edge>> g;",
      "  vector<vector<T>> dp;",
      "  vector<int> par;",
      "  vector<T> ans;",
      "  ReRooting(int n, M merge, L lift) : n(n), merge(merge), lift(lift) {",
      "    g.resize(n);",
      "  }",
      "  void add_edge(int v, int u, Data e) {",
      "    g[v].push_back((Edge) { u, e });",
      "    g[u].push_back((Edge) { v, e });",
      "  }",
      "  vector<T> solve() {",
      "    dp.resize(n);",
      "    par.assign(n, -1);",
      "    ans.resize(n);",
      "    dfs(0);",
      "    bfs(0);",
      "    return ans;",
      "  }",
      "  T dfs(int v, int p = -1) {",
      "    int m = g[v].size();",
      "    dp[v] = vector<T>(m);",
      "    T ret = T();",
      "    for (int i = 0; i < m; i++) {",
      "      auto e = g[v][i];",
      "      if (e.to == p) {",
      "        par[v] = i;",
      "        continue;",
      "      }",
      "      dp[v][i] = lift(dfs(e.to, v), e.data);",
      "      ret = merge(ret, dp[v][i]);",
      "    }",
      "    return ret;",
      "  }",
      "  void bfs(int v, T t = T()) {",
      "    if (par[v] != -1) {",
      "      dp[v][par[v]] = lift(t, g[v][par[v]].data);",
      "    }",
      "    int m = g[v].size();",
      "    vector<T> dpl(m + 1);",
      "    vector<T> dpr(m + 1);",
      "    for (int i = 0; i < m; i++) {",
      "      dpl[i + 1] = merge(dpl[i], dp[v][i]);",
      "    }",
      "    for (int i = m; i > 0; i--) {",
      "      dpr[i - 1] = merge(dpr[i], dp[v][i - 1]);",
      "    }",
      "    ans[v] = lift(dpr[0], Data());",
      "    for (int i = 0; i < m; i++) {",
      "      if (i == par[v]) continue;",
      "      int u = g[v][i].to;",
      "      bfs(u, merge(dpl[i], dpr[i + 1]));",
      "    }",
      "  }",
      "};"
    ]
  }
}